#!/usr/bin/python3

"""
Generated by dichotomous-script-gen
By Ian Duncan
https://github.com/jansky/dichotomous
"""

import sys

def DCParseObjectFile(objectfilename):

	objectfile = ""
	linenum = 1
	
	objects = []
	
	with open(objectfilename,encoding='utf-8') as f:
	
		objectfile = f.read()
	
	objects_raw = objectfile.split("%%")
	
	for object_raw in objects_raw:
	
		conditions_raw = object_raw.splitlines()
		
		obj = {}
		nameFound = False
		conditions = []
		
		for condition_raw in conditions_raw:
		
			if condition_raw.strip() == "" or condition_raw.startswith(';'):
				#Comment
				pass
			else:
				if nameFound == False:
					obj["name"] = condition_raw
					nameFound = True
				else:
					if condition_raw.startswith('!'):
						#Negative
						pass
					else:
						conditions.append(condition_raw)
			linenum += 1
		
		if nameFound == False:
			print("Error: " + objectfilename + ":" + str(linenum) + " A name is required for an object.")
			sys.exit(1)
		
		obj["conditions"] = conditions
		
		objects.append(obj)
	
	return objects
	
def DCCheckRule(rules, obj, rulenum):

	rule = rules[rulenum - 1]
	
	for condition in rule:
	
		if condition["condition"] == "*" and condition["negative"] == False:
			return {'data':condition['data'], 'action':condition['action']}
	
		elif condition["negative"] == True and condition["condition"] not in obj["conditions"]:
			return {'data':condition['data'], 'action':condition['action']}
		
		elif condition["negative"] == False and condition["condition"] in obj["conditions"]:
			return {'data':condition['data'], 'action':condition['action']}
	
	#No result found, so indeterminate
	
	return {'data':'indet','action':'result'}

def DCIterateObjectsRules(rules, objects):

	results = []
	
	for obj in objects:
	
		rulenum = 1
		resultFound = False
		
		while resultFound == False:
		
			result = DCCheckRule(rules, obj, rulenum)
			
			if result['action'] == "result":
			
				resultFound = True
				results.append({'object':obj['name'],'classification':result['data']})
			
			elif result['action'] == "goto":
			
				if result['data'] > len(rules):
					print("Error: " + "Cannot goto rule '" + str(result['data']) + "', as it does not exist.")
					sys.exit(1)
				else:
					if result['data'] == rulenum:
						#Infinite loop detected
						print("Error: Infinite loop detected. Goto rule '" + str(result['data']) + "' from rule '" + str(rulenum) + "'.")
						sys.exit(1)
					else:
						rulenum = result['data']
			else:
				print("Action '" + result['action'] + "' does not exist.")
				sys.exit(2)
	
	return results

def DCPrintResults(results):

	counter = 1
	
	for result in results:
	
		if result['classification'] == "indet":
			print(str(counter) + ". " + result['object'] + ": Indeterminate")
		else:
			print(str(counter) + ". " + result['object'] + ": " + result['classification'])
		counter += 1

def Main(keyrules):

	if len(sys.argv) < 2:
		print("Usage: " + sys.argv[0] + " objects_file.dco")
		sys.exit(1)
	else:
		DCPrintResults(DCIterateObjectsRules(keyrules,DCParseObjectFile(sys.argv[1])))
	
keyrules = eval("[[{'condition': 'uses_ink', 'action': 'goto', 'negative': False, 'data': 3}, {'condition': 'uses_ink', 'action': 'goto', 'negative': True, 'data': 2}], [{'condition': 'uses_wax', 'action': 'result', 'negative': False, 'data': 'Crayon'}, {'condition': 'uses_lead', 'action': 'result', 'negative': False, 'data': 'Colored Pencil'}, {'condition': '*', 'action': 'result', 'negative': False, 'data': 'indet'}], [{'condition': 'has_cover', 'action': 'goto', 'negative': False, 'data': 4}, {'condition': 'has_cover', 'action': 'result', 'negative': True, 'data': 'Ink Pen'}], [{'condition': 'has_clip_on_cover', 'action': 'result', 'negative': False, 'data': 'Sharpie'}, {'condition': 'has_clip_on_cover', 'action': 'result', 'negative': True, 'data': 'Marker'}]]")
if __name__ == "__main__":
	Main(keyrules)
